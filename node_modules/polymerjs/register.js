"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.registerElement = registerElement;
exports.registerStyles = registerStyles;
exports.registerBehavior = registerBehavior;
exports.implementsInterface = implementsInterface;

var _kebabCase = require("lodash/kebabCase");

var _kebabCase2 = _interopRequireDefault(_kebabCase);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
* registerElement will take a Polymer element prototype and upgrades it.
* If you assign a static get method on the element prototype called
* For templates to work, write a static getter method called 'html' on the element prototype
* For styles to work, write a static getter method called 'styles' on the element prototype.
*
* @example
* class HelloComponent {
*      beforeRegister () {
*          this.properties = {
*              planet: {
*                  type: String,
*                  value: "earth"
*              }
*          };
*      }
*
*      static get styles () {
*          return `
*              :host([planet="earth"]) {
*                  background-color: blue;
*              }
*
*              .works-too {
*                  font-weight: bold;
*              }
*          `;
*      }
*
*      get html () {
*          return `<p class="works-too">Hello, [[planet]]`;
*      }
* }
*
* registerElement(HelloComponent);
*
* @author Frederik Wessberg [fwe@dlmma.com]
* @param {object} element - the prototype of the element.
*/

function registerElement(element) {
	var DOM_MODULE = document.createElement('dom-module');
	var STYLES = document.createElement('style', 'custom-style');
	var HTML = document.createElement('template');

	DOM_MODULE.id = (0, _kebabCase2.default)(element.prototype.constructor.name) || element.prototype.elementName || element.elementName || element.prototype.is || element.is;
	element.prototype.is = element.is = DOM_MODULE.id;

	var hasBeforeRegister = element.prototype.hasOwnProperty("beforeRegister");

	if (!hasBeforeRegister) {
		(function () {

			// Build beforeRegister from the prototype getters.
			var properties = element.prototype.properties;
			var hostAttributes = element.prototype.hostAttributes;
			var observers = element.prototype.observers;
			var listeners = element.prototype.listeners;

			element.prototype.beforeRegister = function () {
				if (properties != null) this.properties = properties;
				if (hostAttributes != null) this.hostAttributes = hostAttributes;
				if (observers != null) this.observers = observers;
				if (listeners != null) this.listeners = listeners;
			};
			// Wait with deleting get'ers until the 'beforeRegister' is added to the prototype.
			if (properties != null) delete element.prototype.properties;
			if (hostAttributes != null) delete element.prototype.hostAttributes;
			if (observers != null) delete element.prototype.observers;
			if (listeners != null) delete element.prototype.listeners;
		})();
	}

	DOM_MODULE.appendChild(STYLES);
	if (element.prototype.styles != null) {
		STYLES.textContent = element.prototype.styles;
	} else if (element.styles != null) {
		STYLES.textContent = element.styles;
	}
	DOM_MODULE.appendChild(HTML);
	if (element.prototype.html != null) {
		HTML.innerHTML = element.prototype.html;
	} else if (element.html != null) {
		HTML.innerHTML = element.html;
	}

	DOM_MODULE.createdCallback();
	return Polymer(element);
}

/**
* registerStyles will take a string of css and add it to the document.
*
* @example
* const CONDITIONAL_CSS = `
*  .cool-conditional-style {
*      color: yellow;
*      font-size: 1.1rem;
*  }
* `;
*
* registerStyles(CONDITIONAL_CSS);
*
* @author Frederik Wessberg [fwe@dlmma.com]
* @param {String} styleTemplate - the css template string to add to the document.
*/

function registerStyles(styleTemplate) {
	var STYLE = document.createElement('style');
	STYLE.type = "text/css";
	if (STYLE.styleSheet) STYLE.styleSheet.cssText = styleTemplate;else STYLE.appendChild(document.createTextNode(styleTemplate));
	document.getElementsByTagName("head")[0].appendChild(STYLE);
}

/**
* registerBehavior takes a class and a traditional Polymer-based behavior
* and assigns the properties and methods of the behavior to the class.
*  @example
*  import IronResizeableBehavior from "PolymerElements";
*
*  class AwesomeClass {
*      //Code goes here
*  }
*
* registerBehavior(AwesomeClass, IronResizeableBehavior);
*
* @author Frederik Wessberg [fwe@dlmma.com]
* @param {constructor} to
* @param {Object} behavior
*/
function registerBehavior(to, behavior) {
	var prototype = to.prototype;

	for (var key in behavior) {
		if (behavior.hasOwnProperty(key)) {
			if (isFunction(behavior[key])) prototype[key] = behavior[key];else prototype[key] = _extends({}, prototype[key], behavior[key]);
		}
	}
}

/**
* implementsInterface will verify that the methods and properties listed in the given interface
* are implemented by the given class. It is strongly typed and will throw an error if any type
* differs from the interface.
*
* This MUST be called after calling 'registerElement'. It should usually be the last stuff in a class file.
*
* @example
*  import {registerElement, implementsInterface} from "polymerjs/register";
*  import CoolInterface from "../interfaces/CoolInterface";
*
*  class AwesomeClass {
*      //Code goes here
*  }
*
* registerElement(AwesomeClass);
* implementsInterface(CoolInterface);
*
* An interface is an Object that contains property declarations with types and method signatures:
* @example
* const Interface = {
* 		prop1: String,
*		 	prop2: Boolean,
*		  method1(arg1, arg2){},
*		  method2(){}
* }
*
* @param {constructor} to
* @param {Object} implementedInterface
*/
function implementsInterface(to, implementedInterface) {
	//Don't do anything else if we're in production. The validation is done
	//During development and the production build might be uglified.
	if (isInProduction()) return;
	var prototype = to.prototype;
	for (var key in implementedInterface) {
		if (implementedInterface.hasOwnProperty(key) && key !== "interfaceName") {
			//Check if method or field is implemented
			if (!prototype.hasOwnProperty(key)) throw new Error("Error: " + getConstructorName(to) + " must implement the method or property: \"" + key + "\" from the \"" + implementedInterface.interfaceName + "\" interface!");
			if (prototype.hasOwnProperty(key)) {
				//If it is, perform deep checks and type validation
				if (isObject(implementedInterface[key]) && !isObject(prototype[key])) {
					throw new Error("Error: \"" + key + "\" should be implemented as an Object according to the " + implementedInterface.interfaceName + " interface!");
				}

				if (isObject(implementedInterface[key])) {
					var subObject = implementedInterface[key];
					for (var subkey in subObject) {
						if (subObject.hasOwnProperty(subkey)) {
							if (!prototype[key].hasOwnProperty(subkey)) throw new Error("Error: " + getConstructorName(to) + " must implement the key: \"" + subkey + "\" in the " + key + " Object from the " + implementedInterface.interfaceName + " interface!");
							var implType = prototype[key][subkey];
							var interfType = implementedInterface[key][subkey];
							//If shorthand notation wasn't used, the type is located as a "type" key on the
							//implType object.
							if (implType.type) implType = implType.type;
							var isSameType = implType === interfType;
							if (!isSameType) throw new Error("Error: the property: \"" + subkey + "\" in " + getConstructorName(to) + " must be implemented as type: " + getConstructorName(interfType) + "!");
						}
					}
				} else {
					if (isFunction(implementedInterface[key])) {
						var same = hasSameSignature(prototype[key], implementedInterface[key]);
						if (!same) throw new Error("Error: the signature of the method: " + getSignature(prototype[key]) + " in " + getConstructorName(to) + " must be identical to the one it implements: \"" + getSignature(implementedInterface[key]) + "\" in the " + implementedInterface.interfaceName + " interface!");
					}
				}
			}
		}
	}
}

/**
* returns true if the process.env.NODE_ENV is defined and has a value of "production".
* Otherwise, there is no way to know.
* @returns {boolean}
* @private
*/
function isInProduction() {
	if (process != null && process.env != null && process.env.NODE_ENV != null) {
		return process.env.NODE_ENV.toLowerCase() === "production";
	} else return false; //We don't know the environment. Probably in development.
}

/**
* Given two methods, this will compare their signatures and return true if they are identical.
* @param   {function} method1 - the first comparable method.
* @param   {function} method2 - the second comparable method.
* @returns {boolean} true if the signatures are identical.
* @private
*/
function hasSameSignature(method1, method2) {
	var funcNameRegex = /function (.{1,}\))/;
	var first = funcNameRegex.exec(method1.toString());
	var second = funcNameRegex.exec(method2.toString());
	var firstResults = first.length > 1 ? first[1] : null;
	var secondResults = second.length > 1 ? second[1] : null;
	return firstResults === secondResults;
}

/**
* Takes a method and returns its signature.
* @param   {function} method - the method to subtract the signature from.
* @returns {String} - a String representing the method signature.
* @private
*/
function getSignature(method) {
	var funcNameRegex = /function (.{1,}\))/;
	var results = funcNameRegex.exec(method.toString());
	return results.length > 1 ? results[1] : null;
}

/**
* Takes a constructor and returns the name of it if possible.
* @param   {Class} constructor - the constructor to subtract the name from.
* @returns {String} - the constructor name.
* @private
*/
function getConstructorName(ctor) {
	if (isEnum(ctor)) return "enum";
	var funcNameRegex = /function (.{1,})\(/;
	var results = funcNameRegex.exec(ctor.toString());
	return results && results.length > 1 ? results[1] : "unknown";
}

/**
* Takes anitem and returns true if it is a Map of key-value pairs and all values are identical to their keys.
* for instance:
* @example
* const MyEnum = {
* 		MALE: "MALE", FEMALE: "FEMALE"
* }
* @param   {*} item - the item to check.
* @returns {boolean}  true if item is a Map of key-value pairs and all values are identical to their keys.
* @private
*/
function isEnum(item) {
	if (!isObject(item)) return false;
	for (var key in item) {
		if (item.hasOwnProperty(key)) {
			if (key != item[key]) return false;
		}
	}
	return true;
}

/**
* returns true if the given item is an Object.
* @param   {*} item - the item to check.
* @returns {boolean} whether or not the given item is an Object.
* @private
*/
function isObject(item) {
	var type = typeof item;
	return !!item && type == 'object';
}

/**
* returns true if the given item is a function.
* @param   {*} item - the item to check.
* @returns {boolean} whether or not the given item is a function.
* @private
*/
function isFunction(item) {
	var type = typeof item;
	var isFunc = isObject(item) || type === "function";
	var objectProto = Object.prototype;
	var objToString = objectProto.toString;
	var funcTag = '[object Function]';
	return isFunc && objToString.call(item) == funcTag;
}

exports.default = registerElement;